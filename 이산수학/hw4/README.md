Homework 4
--------

<p align=right>컴퓨터공학부 2013-11392 김지현</p>

#### 1.
> 1/(2n) <= {1 * 3 * 5 * ... (2n - 1)}/(2 * 4 * ... * 2n)

수학적 귀납법을 사용한다.

*Basis Step:* n = 1인경우 아래와 같이 성립한다

- 1/(2) <= {1}/(2)

*Inductive Step:* n = k인경우 위의 식이 성립한다고 가정하고, n = k+1일때에도 성립함을 보이자

- 1/(2k) <= {1 * 3 * 5 * ... (2k - 1)}/(2 * 4 * ... * 2k)

- 1/(2(k+1) = 1/(2k) * (2k)/(2k+2)   <br>
  <= {1 * 3 * 5 * ... (2k - 1)}/(2 * 4 * ... * 2k) * (2k)/(2k+2)   <br>
  <= {1 * 3 * 5 * ... (2k - 1)}/(2 * 4 * ... * 2k) * (2k + 1)/(2k+2)  <br>
  = {1 * 3 * 5 * ... (2k - 1) * (2k + 1)}/(2 * 4 * ... * 2k * 2(k+1))

n = k 일때 성립한다고 가정하면, 위와 같이 n = k+1 일때에도 성립함을 알 수 있다.
수학적 귀납법에 의해, 문제에서 제시한 명제가 참임이 증명되었다.

#### 2.
x와 y가 positive integers여도 x-1나 y-1도 positive integers라는 보장은 존재하지
않는다. (e.g. x = 1 인 경우) 그래서 문제의 *Inductive Step* 부분이 틀렸다.

#### 3.
*Bases step:*

- n = 1 = 4*0 + 1 인 경우: 자명하게 선공이 진다.
- n = 2 = 4*0 + 2 인 경우: 선공이 1개를 가져가면 후공이 진다.
- n = 3 = 4*0 + 3 인 경우: 선공이 2개를 가져가면 후공이 진다.
- n = 4 = 4*1 + 0 인 경우: 선공이 3개를 가져가면 후공이 진다.

*Inductive step:*

아래 명제가 j = 0,1,2,..k 에 대해 참이라고 가정해보자.

- n = 4j + 1 인 경우: 후공이 이긴다
- n = 4j + 2 인 경우: 선공이 이긴다
- n = 4j + 3 인 경우: 선공이 이긴다
- n = 4j + 4 인 경우: 선공이 이긴다

이때 위의 명제가 j = k+1 에 대해서도 참임을 증명해보겠다.

-   n = 4k + 5 인 경우: 무조건 후공이 이긴다.

    여기서 선공(1P)가 몇개를 가져가든, 2P는 n = 4k + 2, 4k + 3, 4k + 4 인 게임을
    선공으로 플레이하는것과 같은 상황에 놓인다. 세 경우 모두 본래의 가정에 의해
    2P의 승리가 보장되어있으므로, n = 4k + 5 게임은 무조건 2P(후공)이 이긴다.

-   n = 4k + 6 인 경우: 선공이 이긴다.

    선공(1P)이 하나만 가져가야한다. 1P가 하나만 가져갈경우 2P는 n = 4k + 5인
    게임을 선공으로 플레이하게되는데, 바로 위에서 내린 결론에 의해 2P는 무조건
    그 게임을 지게되어있어, 1P가 이긴다.

-   n = 4k + 7 인 경우: 선공이 이긴다.

    선공(1P)이 두개만 가져가야한다. 1P가 두개만 가져갈경우 2P는 n = 4k + 5인
    게임을 선공으로 플레이하게되는데, 바로 위에서 내린 결론에 의해 2P는 무조건
    그 게임을 지게되어있어, 1P가 이긴다.

-   n = 4k + 8 인 경우: 선공이 이긴다.

    선공(1P)이 세개만 가져가야한다. 1P가 세개만 가져갈경우 2P는 n = 4k + 5인
    게임을 선공으로 플레이하게되는데, 바로 위에서 내린 결론에 의해 2P는 무조건
    그 게임을 지게되어있어, 1P가 이긴다.

#### 4.
x < y 를 만족하는 두 실수 x, y 가 있다고 가정하자.

> **Archimedean property** - For every real number x there exists an integer n
> such that n > x.

Archimedean property에 의해, x < y 일경우 a > 1/(y - x)를 만족하는 양의 정수 a이
항상 존재한다. `1/(y - x)`가 양수이기 때문이다. 이때 위의 부등식을 변형시키면
`ax + 1 < ay`가 된다.

이때 정수 `b = floor(ax)`를 정의하면, 올림 연산자의 정의상 `b <= ax < b + 1` 가
항상 성립하고, 이를 변형시키면 `b + 1 <= ax + 1`이 된다.

- `ax + 1 < ay`
- `b + 1 <= ax + 1`

위의 두 부등식을 결합하면 `b + 1 < ay`가 된다.

`ax < b + 1 < ay`이므로, `x < (b + 1)/a < y` 이다. a와 b 모두 정수이므로, `(b +
1)/a`는 유리수이다. x와 y 사이엔 유리수 `(b + 1)/a`가 항상 존재함을 밝혔다.

#### 5.
##### a)

1.  (2, 3), (3, 2)
2.  (4, 6), (5, 5), (6, 4)
3.  (6, 9), (7, 8), (8, 7), (9, 6)
4.  (8, 12), (9, 11), ..., (11, 9), (12, 8)
5.  (10, 15), (11, 14), ..., (14, 11), (15, 10)

##### b)

`K(n)`을 S의 recursive definition을 n번 application하여 만들어진 S의 모든
원소들의 집합이라고 정의하겠다.

`P(n)`을 "for all (a, b) ∈ K(n), `5|a + b` is true"로 정의하겠다.

**Basis Step:** `P(0)`은 참이다.

K(0) = { (0, 0) }인데 `5|0 + 0`은 참이므로 `P(0)`도 참이다.

**Recursive Step:** P(0), P(1), P(2), ... , P(k)가 모두 참이라고 가정했을 때,
P(k+1)도 참임을 보이겠다.

P(k)가 참이므로, for all (a, b) ∈ K(k) 는 참이다.

이때 집합 S의 정의상 "K(k+1) = { (a+2, b+3) | (a, b) ∈ K(k) } ∪ { (a+3, b+2) | (a, b) ∈ K(k) }"
인데, `5|(a + 2) + (b + 3)`와 `5|(a + 3) + (b + 2)` 모두 참이므로 P(k+1)도
참이다.

##### c)

**Basis Step:** (0, 0)의 경우, `5|0 + 0`는 참이다.

**Recursive Step:** `5|a + b`가 참일경우, `5|(a + 2) + (b + 3) = 5|a + b + 5`도
참이고, `5|(a + 3) + (b + 2) = 5|a + b + 5`도 참이다.

따라서 모든 `(a, b) ∈ S`에 대해, `5|a + b`는 참이다.

#### 6.
P(m, n) 를 "a<sub>m,n</sub> = 2(m + n) +1" 로 정의하겠다.

**Basis Step:** P(1,1) 은 참이다. "a<sub>1,1</sub> = 5 = 2(1 + 1) + 1"이기
때문이다.

**Recursive Step:** P(m, n)이 참일경우, 아래 명제가 참임을 증명하겠다.

- if n = 1; P(m+1, n) 도 참이다
- otherwise; P(m, n+1) 도 참이다

P(m, n)이 참이므로 "a<sub>m,n</sub> = 2m + 2n + 1" 이다. 이때

-   n이 1인경우

    정의에 의해 "a<sub>m+1,n</sub> = a<sub>m,n</sub> + 2" 이다.

    그래서 "a<sub>m+1,n</sub> = 2{(m+1) + n} + 1" 은 참이다.

-   n이 1보다 큰경우

    정의에 의해 "a<sub>m,n+1</sub> = a<sub>m,n</sub> + 2" 이다.

    그래서 "a<sub>m,n+1</sub> = 2{m + (n+1)} + 1" 은 참이다.

Generalized induction에 의해, 모든 (m, n) ∈ Z<sup>+</sup> x Z<sup>+</sup> 에
"a<sub>m,n</sub> = 2m + 2n + 1"은 성립한다.

#### 7.
```
def algorithm(n: nonnegative_int):
  if n == 0: return 1
  if n == 1: return 2
  return algorithm(n - 1) * algorithm(n - 2)
```

#### 8.
- [4, 8, 2, 7, 1, 6, 3, 5]
- [4, 8, 2, 7] [1, 6, 3, 5]
- [4, 8] [2, 7] [1, 6] [3, 5]
- [4] [8] [2] [7] [1] [6] [3] [5]
- [4, 8] [2, 7] [1, 6] [3, 5]
- [2, 4, 7, 8] [1, 3, 5, 6]
- [1, 2, 3, 4, 5, 6, 7, 8]
