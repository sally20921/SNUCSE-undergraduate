<h1 align="center">프로그래머 고통의 역사</h1>
<p align="right">2013-11392, 김지현</p>

프로그래머들은 항상 고통받아왔다. 대중적으로 유명한 프로그래밍 언어는 항상
난개발된 언어들이었다. 난개발된 언어는 우리의 생각을 제한해왔고, 우리는 난개발된
언어 안에 갇혀살았다. 본 글은 C와 C++이 어떻게 하여 생겨났는지, 어떤 문제를
지니고있는지, 우리가 추구해야할 방향은 무엇인지를 간략하게 훑는다.

--------

프로그래머들은 항상 고통받아왔다. 때로는 기술적인 한계로 인한 현실과의
타협이기도 했고, 때로는 관리되지 않은 코드들과의 싸움이기도 했다. 하지만 그들을
고통받게하는 그들의 제일 큰 적은 언제나 하나였다. 언어다.

비극적이게도, 성공적인(Successful) 프로그래밍 언어가 되는 조건은 그 언어가
얼마나 잘 디자인되었느냐가 아니다. 역사적으로 성공한 프로그래밍언어들 가운데
상당수는 어처구니 없는 과정에서 탄생하였으며(javascript), 난개발되었고(php),
철학과 논리보다는 실용성과 결과주의적으로 만들어졌다. C 언어의 창시자인 데니스
리치는 자신이 만든 언어에 대해 "C는 유별나고 결함이 있으며, 엄청나게
성공했다"[1]고 평가하였다. 펄(Perl) 프로그래밍 언어의 창시자인 래리 월은, 자신이
만든 펄에 대해 다음과 같이 평가하였다.

> 어빈에 캘리포니아 주립대학을 처음 지을 때 사람들은 그냥 아무렇게나 건물을
올렸다. 보도도 없이 잔디만 심었다. 그리고는 다음 해에 잔디가 밟혀 생긴 길을 따라
보도를 깔았다. 펄은 바로 그런 언어다. 기본 원칙을 갖고 설계된 언어가 아니라, 이
잔디에 깐 보도와 같은 언어다. [2]

프로그래머들은 생각을 제한받아왔다. 프로그래밍 언어는 곧 그 프로그래머의 생각하는 방법이다.
루드비히 비트겐슈타인은 "언어의 한계가 곧 세계의 한계"라고 말하였다. 프로그래밍
언어는 프로그래머의 세계이며, 프로그래밍 언어의 한계는 곧 그 프로그래머의
한계이다. 수십년동안 수많은 기성 프로그래머들은 난개발된 프로그래밍 언어로
자신의 세계를 제한받아왔으며, 억눌린 생각으로 개발하여왔다. C로 짜여진 수많은
프로그램들의 어이없는 보안취약점, 급발진을 일으키는 차 제어 소프트웨어 등이 모두
이 억눌린 생각의 결과물이다.

공리계는 자신의 무모순성을 증명할 수 없다. 세계를 제한받아온 프로그래머들은
자신의 생각이 억눌려있다는 사실을 알 수 없다. 한가지 언어로만 생각하는
프로그래머들에게는, 그 언어에 의한 모든 부조리함이 "프로그래머라면 당연히
견뎌야하는 것"이며, 그 모든 불합리함이 "극복해야할 도전"이다. 그 생각은 새로운
언어를 접하기 전까지 변하지 않는다.

새로운 언어를 접하기 전까지는.

프로그래머는 새로운 언어를 배움으로써 생각의 지평을 넓힌다. 새로운 패러다임을
맛보고, 새로운 생각하는 방법을 배우며, 보지못했던 곳을 볼수있는 시야가 생긴다.
언어로 세계를 늘리는것이다. 여러 프로그래밍 언어를 접하고, 자신의 세계가
이전보다 훨씬 넓어진 후에 과거를 돌아보면 그제서야 깨닫는다. 자신이 눈치채지도
못하는 사이에 스스로를 얼마나 고통받게하고있었는지.

익숙한 이야기이지 않은가? 대부분 C 언어로 프로그래밍을 시작하였을 한국의 내 또래
개발자들에게는 너무나도 익숙한 상황이다. 전문가들이 주의에 주의를 기울여서
사용해야하는 C, C++ 이라는 언어를 아무것도 모르는 병아리 개발자들에게 당연한것처럼
가르친 후, 잘못 만들어진 언어로 개발자들을 다이아몬드처럼 단련시킨 뒤, 나중에
그들이 스스로 다른 언어를 배웠을때 왜 그렇게 프로그래밍을 힘들게 해왔나는
허탈감. 쉽고 편한 언어가 갑자기 대중화되어가는 과정에 있던 우리세대에겐
남이야기가 아니다.

이제 벌써 옛날이야기같지만, 불과 10년 전만해도 개발자들은 게임서버 개발에 C#과
같은 고급언어를 쓸 수 있으리라고는 상상조차 못하였다. 무엇이 그들을 C 와 C++로
내몰았는가? C/C++은 왜 그렇게 프로그래머를 극한으로 몰아붙이는가?

#### C & C++
C언어는 Unix 운영체제를 개발하는 과정에서 생겨났다. BCPL을 전신으로, B언어, New
B, C 의 순서대로 개발이 진행되었으며, B 언어의 경우 부트스트래핑 이후 B
컴파일러를 B로 재작성할정도로 적극적으로 오랜기간동안 쓰였다. 그 과정에서 B
언어의 한계가 잘 드러났고 C언어는 B언어에 비해 훨씬 하드웨어를 직접적으로
컨트롤할 수 있고, 효율적인 위험한 언어로 탄생하였다. 이후로도 C는 표준화과정과
제정을 반복하며, 한가지 일을 잘하는, 단순하지만 실수를 허용하는 언어로
발전하였다. [3]

C++은 C with Classes를 표방하며 등장한 언어이다. 객체지향 C 를 추구하며, 문법
확장을 거듭하며 성장하였고, C와도 계속 영향을 주고받으며 성장하였다. C++
2.0이라고도 부르는 C++89와 C++03 이후로 한동안 발전이 뜸하다가, C++11에서
언어차원의 대대적인 대격변을 겪고 move semantic, variadic template 등 여러가지
복잡한 개념들을 대대적으로 수용하였다. 현재 최신 표준은 C++14이고, C++17 (속칭
C++1z)를 준비하면서 점점 엄청난 규모의 언어가 되어가고있다.

C와 C++의 공통적인 특징은 '프로그래머를 믿는다' 에 있다. 대부분의 현대
프로그래밍 언어는 언제나 프로그래머의 실수를 가정한다. 믿을수있는것은 오로지
기계뿐이고, 사람은 언제나 실수를 한다고 생각했다. 하지만 이것은 지금의 이야기,
불과 10년 전만해도 안전함따위 CPU 성능과 비교하면 얼마든지 포기해도 되는
문제였다. 그 결과가 바로 우리에게 친숙한 수많은 Null pointer exception,
블루스크린, Segmentation fault이다.

C++은 그 외에도 추가적인 문제가 있다. 초기 언어 문법이 탄탄한 이론적 배경에
기반하지 않고 익숙함과 개발편의성 위주로 구성되다보니, 정말 수많은 사람들이
C++을 사용하고 C++이 정말 다양한 스펙트럼의 요구를 충족시켜줘야 하는
현재시점에선 문법이 정말 괴물처럼 복잡해지고있다. 단순히 expression을 분류하는
기준도 과거에는 단순히 lvalue, rvalue로 둘이었던것이 C++11 이후 현재시점에선
lvalue, xvalue, prvalue 셋으로 구분되며 이들을 그룹지어 glvalue, rvalue라고
이름붙이는 등, 원래도 어려웠던것이 점점 상식과 멀어지고있다.

인정해야한다. C와 C++은 정말 못난 언어다. 시스템 프로그래밍에 있어서는 어쩔 수
없는 선택지로 쓰일 수는 있지만, 2000년대 초반에처럼, 일반 어플리케이션
개발에까지 C/C++이 쓰이는것은 두번다시 반복되어선 안되는 비극이다.

그렇다면 우리가 나아가야할 방향은 무엇인가?

#### Modern Programming Languages
우리는 이미 답을 알고있다. 이전의 프로그래밍 언어와는 달리, 탄탄한 이론적 기반을
바탕으로 프로그래밍하는것이다. 힌들리 밀너 타입시스템을 채용한 ML계열 언어들 [4],
Purely-functional을 표방하는 하스켈, 리니어 타입과 메모리 세이프티를 보장하는
Rust 등이 이에 해당한다. 이전과는 달리, "올바르게" 만들어진 프로그래밍 언어를
사용하면 되는것이다. [5]

하스켈은 미래지향적인 함수형 언어를 표방한다. 수많은 함수형 언어들 가운데에서도
하스켈은 항상 논란의 중심이며 언제나 튄다. 하스켈은 ML과 마찬가지로 힌들리 밀너
타입시스템을 사용하며, 기본적 불변성(immutability by default)과 통제된 가변성을
보장한다. 하지만 여타 함수형언어와는 다르게 하스켈은 함수들의 참조 투명성을
보장하며, 이러한 성질을 사용해 광범위한 constant folding과 스트림 퓨전(stream
fusion)을 지원하며, 궁극적으로는 Lazy evaluation을 가능케 해준다. [6]

하스켈의 동시성은 어처구니가 없다. 일반적으로 프로그래머에게 동시성이란 데드락과
레이스 컨디션, 재현할 수 없는 버그와 메모리 오염을 연상시키며, 프로그래머들의
뇌를 과부하시키는 프로그래머의 주적이지만, 하스켈은 pure function과 Lazy
evaluation을 사용해 별다른 조치가 되어있지 않은 코드를 자동으로 여러 스레드로
분산시켜준다. 이를 스파크(spark)라고 부르는데, 기성 프로그래머들이 동시성을
지원하기위해 어떠한 대가를 지불하는지 생각하면 그저 어처구니가 없을분이다.

Rust는 C++을 대체하기 위해 만들어진 언어이다. Firefox 브라우저 개발에 사용하기
위해 Mozilla 사에서 개발하였으며, "올바르게 다시 만든 C++"로 Rust에 대한 설명을
요약할 수 있다. 하스켈의 타입시스템을 전반적으로 도입하되 C-like 언어처럼 쓸 수
있도록 first class function이나 모나드는 차용하지 않았으며, ownership check와
리니어 타입 시스템을 사용하여 GC를 쓰지 않는 효율적인 메모리 관리와 Guaranteed
memory safety를 보장하였다. Rust는 PL 학계에서 연구해온 고급 기술들(JIT, GC)과는
거리가 먼 삶을 살아온 시스템 프로그래머들을 위한 학계의 선물인 셈이다.

#### 결론
프로그래밍 언어 연구자들의 노력에도 불구하고, 산업계들은 오랜시간동안 새로운
언어의 도입을 꺼려왔다. 하지만 상대적으로 레거시코드의 압박이 덜한 웹개발 시대가
열리고, 자바스크립트나 파이썬 루비와 같은 현대적인 언어들이 산업계에 일단
대대적으로 풀리자 개발자들의 새로운 언어 도입에 대한 부담이 줄어들어
보수적이었던 기존 업계에도 PL의 바람이 불고있다.

언어의 한계가 곧 세계의 한계이다. 프로그래밍 언어를 연구하는것은 우리의 세계를
확장하는것이다. 우리가 의사소통하기위해, 혹은 예술적인 가치를 위해 열심히 국어를
공부하듯이, 프로그래밍 언어도 계속하여 연구하고 개선해야한다. SMT solver를
사용한 컴파일러 최적화, Concurrent GC 등 프로그래밍 언어에서 개선해야 할 문제는
여전히 산재되어있다. 프로그래밍 언어의 시대는, 이제 막 시작했을뿐이다.

--------

1.  https://en.wikiquote.org/wiki/Dennis_Ritchie#Quotes

    > c is quirky flawed and an enormous success

2.  https://www.goodreads.com/author/quotes/89118.Larry_Wall

    > When they first built the University of California at Irvine they just put
    the buildings in. They did not put any sidewalks, they just planted grass.
    The next year, they came back and put the sidewalks where the trails were in
    the grass. Perl is just that kind of language. It is not designed from first
    principles. Perl is those sidewalks in the grass.

3.  http://ropas.snu.ac.kr/~kwang/4190.310/sociology/c-history.htm
4.  https://blogs.janestreet.com/caml-trading-talk-at-cmu/
5.  http://cufp.org/videos/
6.  http://www.scs.stanford.edu/11au-cs240h/
